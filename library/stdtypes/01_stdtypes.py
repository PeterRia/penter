"""
逻辑值检测
被定义为假值的常量: None 和 False。
任何数值类型的零: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
空的序列和多项集: '', (), [], {}, set(), range(0)
"""


# 取模，Python中可直接用%，计算模，r = a % b
def mod(a, b):
    c = a // b
    r = a - c * b
    return r


# 取余
def rem(a, b):
    c = int(a / b)
    r = a - c * b
    return r

print(9 // 4, 9 // -4, -9 // 4, -9 // -4)
print(int(9 / 4), int(9 / -4), int(-9 / 4), int(-9 / -4))

print(mod(9, 4), 9 % 4)
print(mod(9, -4), 9 % -4)
print(mod(-9, 4), -9 % 4)
print(mod(-9, -4), -9 % -4)

print(rem(9, 4))
print(rem(9, -4))
print(rem(-9, 4))
print(rem(-9, -4))
"""
取模运算和取余运算是两个概念，虽然他们有重叠部分，但又不一致。不一致的地方在于对负整数进行除法时，操作不一样。
　　对于整数 a 和 b，进行取模运算和取余运算可以总结分为 2 个步骤：
　　1. 计算整数商： c = 取整（a / b）;
　　2. 计算模或余数：r = a - c * b .
　　两者的区别就在于第 1 步中的计算整数商不同，取模是向负无穷方向取整（即向下取整），取余是向 0 方向取整（即商大于 0 时向下取整，小于0时向上取整）。 

简单说：取模看b的+-  取余看a的+-
"""

# bytes 对象是由单个字节构成的不可变序列
# bytearray 对象是 bytes 对象的可变对应物
